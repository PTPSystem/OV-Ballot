# Technical Implementation Plan for OV-Ballot

## Overview

OV-Ballot is an NCFCA (National Christian Forensics and Communications Association) club speech ballot application. This system allows judges to evaluate speakers across 10 different speech event types using official NCFCA 2025-2026 rubrics. The application features a simplified workflow with no login requirements for judges, automatic ballot distribution via magic links, and PDF generation matching official NCFCA ballot templates.

**Key Features:**

- **10 Speech Event Types**: Persuasive, Oratorical, Open Interpretation, Informative, Impromptu, Extemporaneous, Duo Interpretation, Digital Presentation, Biblical Thematic, and Apologetics
- **Zero-friction Judge Experience**: No login required, immediate access when tournament is active
- **5-Category Rubric Scoring**: Each ballot scores Content, Organization & Citations, Vocal Delivery, Physical Delivery, and Impact (1-5 scale)
- **Auto-save**: Real-time saving of judge input to prevent data loss
- **Magic Link Distribution**: Automatic email delivery of personalized ballot access links to competitors/parents
- **Official PDF Generation**: Pixel-perfect replicas of NCFCA 2025-2026 ballot templates
- **Simple Admin Panel**: Single-password protected interface for tournament management
- **Tournament State Management**: Only one active tournament at a time, with automatic archiving

## Development Architecture

### Frontend

- **Framework**: React with TypeScript
- **Build Tool**: Vite (faster development experience)
- **UI Library**: Tailwind CSS (responsive, tablet-optimized design)
- **PDF Generation**: react-pdf or jsPDF with custom templates for all 10 ballot types
- **Form Management**: React Hook Form with auto-save functionality
- **State Management**: React Context API (lightweight for this use case)
- **API Client**: Axios with TypeScript interfaces
- **Hosting (Dev)**: Local development server (Vite dev server)
- **Hosting (Prod)**: Azure Static Web Apps

### Backend/Database (Development)

- **Database**: PostgreSQL 14+
- **Server**: 192.168.1.46:5432
- **Admin User**: bw_pg_admin
- **Password**: %LtT#N492VFjXOso
- **ORM**: Prisma for type-safe database access
- **API**: Node.js/Express REST API
- **Email Service**: Nodemailer or SendGrid for magic link distribution
- **Magic Link Generation**: UUID-based tokens with 1-year expiration
- **Session Storage**: Browser localStorage for judge ballot drafts (device-specific, 48-hour persistence)

### Backend/Database (Production - Future)

- **Database**: Microsoft Dataverse
- **API**: Dataverse Web API
- **Integration**: Power Platform

## Development Data Model (PostgreSQL)

### Tables Schema

#### voters

```sql
CREATE TABLE voters (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    full_name VARCHAR(100) NOT NULL,
    azure_ad_object_id VARCHAR(100) UNIQUE,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_voters_email ON voters(email);
CREATE INDEX idx_voters_azure_id ON voters(azure_ad_object_id);
```

#### ballots

```sql
CREATE TABLE ballots (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(200) NOT NULL,
    description TEXT,
    start_date TIMESTAMP NOT NULL,
    end_date TIMESTAMP NOT NULL,
    status VARCHAR(20) DEFAULT 'draft',
    -- status values: draft, active, closed, cancelled
    allow_multiple_votes BOOLEAN DEFAULT false,
    created_by UUID REFERENCES voters(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_ballots_status ON ballots(status);
CREATE INDEX idx_ballots_dates ON ballots(start_date, end_date);
```

#### candidates

```sql
CREATE TABLE candidates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ballot_id UUID NOT NULL REFERENCES ballots(id) ON DELETE CASCADE,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    display_order INT DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_candidates_ballot ON candidates(ballot_id);
CREATE INDEX idx_candidates_order ON candidates(ballot_id, display_order);
```

#### votes

```sql
CREATE TABLE votes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ballot_id UUID NOT NULL REFERENCES ballots(id) ON DELETE CASCADE,
    voter_id UUID NOT NULL REFERENCES voters(id),
    candidate_id UUID NOT NULL REFERENCES candidates(id),
    voted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address INET,
    user_agent TEXT,
    UNIQUE(ballot_id, voter_id, candidate_id)
);

CREATE INDEX idx_votes_ballot ON votes(ballot_id);
CREATE INDEX idx_votes_voter ON votes(voter_id);
CREATE INDEX idx_votes_candidate ON votes(candidate_id);
```

#### audit_logs

```sql
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    action VARCHAR(50) NOT NULL,
    -- action values: login, vote_cast, ballot_created, ballot_updated, etc.
    entity_type VARCHAR(50),
    entity_id UUID,
    user_id UUID REFERENCES voters(id),
    ip_address INET,
    user_agent TEXT,
    details JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_audit_action ON audit_logs(action);
CREATE INDEX idx_audit_user ON audit_logs(user_id);
CREATE INDEX idx_audit_created ON audit_logs(created_at);
```

## TypeScript Type Definitions

```typescript
// types/database.ts
export interface Voter {
  id: string;
  email: string;
  full_name: string;
  azure_ad_object_id?: string;
  is_active: boolean;
  created_at: Date;
  updated_at: Date;
}

export interface Ballot {
  id: string;
  title: string;
  description?: string;
  start_date: Date;
  end_date: Date;
  status: 'draft' | 'active' | 'closed' | 'cancelled';
  allow_multiple_votes: boolean;
  created_by?: string;
  created_at: Date;
  updated_at: Date;
}

export interface Candidate {
  id: string;
  ballot_id: string;
  name: string;
  description?: string;
  display_order: number;
  is_active: boolean;
  created_at: Date;
  updated_at: Date;
}

export interface Vote {
  id: string;
  ballot_id: string;
  voter_id: string;
  candidate_id: string;
  voted_at: Date;
  ip_address?: string;
  user_agent?: string;
}

export interface AuditLog {
  id: string;
  action: string;
  entity_type?: string;
  entity_id?: string;
  user_id?: string;
  ip_address?: string;
  user_agent?: string;
  details?: Record<string, any>;
  created_at: Date;
}
```

## Prerequisites

- Node.js 18+ and npm
- PostgreSQL client tools (psql)
- Git
- Code editor (VS Code recommended)
- Azure account (for production deployment later)

## Step-by-Step Development Setup

### 1. Database Setup

```bash
# Connect to PostgreSQL
psql -h 192.168.1.46 -p 5432 -U bw_pg_admin -d postgres

# Create database
CREATE DATABASE ov_ballot_dev;

# Connect to the new database
\c ov_ballot_dev

# Run the table creation scripts from the Data Model section above
# (Execute each CREATE TABLE and CREATE INDEX statement)
```

### 2. Initialize React/TypeScript Frontend

```bash
# Create React app with TypeScript template
npx create-react-app ov-ballot-frontend --template typescript

cd ov-ballot-frontend

# Install dependencies
npm install @mui/material @emotion/react @emotion/styled
npm install axios
npm install react-router-dom
npm install @azure/msal-browser @azure/msal-react

# Install dev dependencies
npm install --save-dev @types/react-router-dom
```

### 3. Initialize Backend API (Node.js/Express)

```bash
# Create backend directory
mkdir ov-ballot-backend
cd ov-ballot-backend

# Initialize Node.js project
npm init -y

# Install dependencies
npm install express cors dotenv
npm install pg
npm install prisma @prisma/client
npm install express-validator
npm install jsonwebtoken bcrypt

# Install TypeScript and dev dependencies
npm install --save-dev typescript @types/node @types/express @types/cors
npm install --save-dev ts-node nodemon
npm install --save-dev @types/pg

# Initialize TypeScript
npx tsc --init

# Initialize Prisma
npx prisma init
```

### 4. Configure Prisma for PostgreSQL

Create `.env` file in backend:

```env
DATABASE_URL="postgresql://bw_pg_admin:%LtT%23N492VFjXOso@192.168.1.46:5432/ov_ballot_dev?schema=public"
JWT_SECRET="your-jwt-secret-here"
PORT=3001
```

Update `prisma/schema.prisma`:

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Voter {
  id               String     @id @default(uuid()) @db.Uuid
  email            String     @unique @db.VarChar(255)
  fullName         String     @map("full_name") @db.VarChar(100)
  azureAdObjectId  String?    @unique @map("azure_ad_object_id") @db.VarChar(100)
  isActive         Boolean    @default(true) @map("is_active")
  createdAt        DateTime   @default(now()) @map("created_at") @db.Timestamp
  updatedAt        DateTime   @updatedAt @map("updated_at") @db.Timestamp
  
  votes            Vote[]
  ballots          Ballot[]
  auditLogs        AuditLog[]

  @@map("voters")
}

model Ballot {
  id                 String     @id @default(uuid()) @db.Uuid
  title              String     @db.VarChar(200)
  description        String?    @db.Text
  startDate          DateTime   @map("start_date") @db.Timestamp
  endDate            DateTime   @map("end_date") @db.Timestamp
  status             String     @default("draft") @db.VarChar(20)
  allowMultipleVotes Boolean    @default(false) @map("allow_multiple_votes")
  createdBy          String?    @map("created_by") @db.Uuid
  createdAt          DateTime   @default(now()) @map("created_at") @db.Timestamp
  updatedAt          DateTime   @updatedAt @map("updated_at") @db.Timestamp
  
  creator            Voter?     @relation(fields: [createdBy], references: [id])
  candidates         Candidate[]
  votes              Vote[]

  @@map("ballots")
}

model Candidate {
  id            String     @id @default(uuid()) @db.Uuid
  ballotId      String     @map("ballot_id") @db.Uuid
  name          String     @db.VarChar(200)
  description   String?    @db.Text
  displayOrder  Int        @default(0) @map("display_order")
  isActive      Boolean    @default(true) @map("is_active")
  createdAt     DateTime   @default(now()) @map("created_at") @db.Timestamp
  updatedAt     DateTime   @updatedAt @map("updated_at") @db.Timestamp
  
  ballot        Ballot     @relation(fields: [ballotId], references: [id], onDelete: Cascade)
  votes         Vote[]

  @@map("candidates")
}

model Vote {
  id          String     @id @default(uuid()) @db.Uuid
  ballotId    String     @map("ballot_id") @db.Uuid
  voterId     String     @map("voter_id") @db.Uuid
  candidateId String     @map("candidate_id") @db.Uuid
  votedAt     DateTime   @default(now()) @map("voted_at") @db.Timestamp
  ipAddress   String?    @map("ip_address")
  userAgent   String?    @map("user_agent") @db.Text
  
  ballot      Ballot     @relation(fields: [ballotId], references: [id], onDelete: Cascade)
  voter       Voter      @relation(fields: [voterId], references: [id])
  candidate   Candidate  @relation(fields: [candidateId], references: [id])

  @@unique([ballotId, voterId, candidateId])
  @@map("votes")
}

model AuditLog {
  id         String     @id @default(uuid()) @db.Uuid
  action     String     @db.VarChar(50)
  entityType String?    @map("entity_type") @db.VarChar(50)
  entityId   String?    @map("entity_id") @db.Uuid
  userId     String?    @map("user_id") @db.Uuid
  ipAddress  String?    @map("ip_address")
  userAgent  String?    @map("user_agent") @db.Text
  details    Json?      @db.JsonB
  createdAt  DateTime   @default(now()) @map("created_at") @db.Timestamp
  
  user       Voter?     @relation(fields: [userId], references: [id])

  @@map("audit_logs")
}
```

### 5. Project Structure

```text
ov-ballot/
├── frontend/
│   ├── public/
│   ├── src/
│   │   ├── components/
│   │   │   ├── Auth/
│   │   │   ├── Ballots/
│   │   │   ├── Voting/
│   │   │   └── Results/
│   │   ├── services/
│   │   │   ├── api.ts
│   │   │   └── auth.ts
│   │   ├── types/
│   │   │   └── index.ts
│   │   ├── App.tsx
│   │   └── index.tsx
│   ├── package.json
│   └── tsconfig.json
├── backend/
│   ├── src/
│   │   ├── controllers/
│   │   ├── routes/
│   │   ├── middleware/
│   │   ├── utils/
│   │   └── index.ts
│   ├── prisma/
│   │   └── schema.prisma
│   ├── .env
│   ├── package.json
│   └── tsconfig.json
└── TECHNICAL_IMPLEMENTATION_PLAN.md
```

### 6. Run Database Migrations

```bash
# From backend directory
npx prisma generate
npx prisma db push
```

### 7. Start Development Servers

```bash
# Terminal 1 - Backend
cd ov-ballot-backend
npm run dev

# Terminal 2 - Frontend
cd ov-ballot-frontend
npm start
```

## Security Considerations

- **Password Storage**: Never commit database passwords to Git. Use `.env` files and add to `.gitignore`
- **SQL Injection**: Use Prisma's parameterized queries
- **Vote Integrity**: Implement transaction logging and immutable vote records
- **Authentication**: Use Azure AD for production; implement JWT for development
- **HTTPS**: Required for production deployment
- **Rate Limiting**: Implement on API endpoints to prevent abuse
- **Input Validation**: Validate all user inputs on both frontend and backend

## Migration Path to Azure/Dataverse (Future)

When ready to deploy to production:

1. Create Azure resources (Resource Group, Static Web App, Key Vault)
2. Set up Azure AD App Registration
3. Create Power Platform environment with Dataverse
4. Migrate data from PostgreSQL to Dataverse using Power Platform tools
5. Update API calls to use Dataverse Web API
6. Deploy frontend to Azure Static Web Apps
7. Configure authentication and authorization

## Development Checklist

- [ ] PostgreSQL database created and accessible
- [ ] Database tables created with proper indexes
- [ ] React/TypeScript frontend initialized
- [ ] Node.js/Express backend initialized
- [ ] Prisma ORM configured and connected
- [ ] Basic API endpoints created (health check)
- [ ] Authentication middleware implemented
- [ ] Voter registration/login flow working
- [ ] Ballot creation UI and API completed
- [ ] Candidate management implemented
- [ ] Voting flow completed with validation
- [ ] Results viewing implemented
- [ ] Audit logging functional
- [ ] Unit tests written for critical functions
- [ ] Integration tests for API endpoints
- [ ] Security review completed
- [ ] Documentation updated
- [ ] Ready for user acceptance testing

## Next Steps

1. Set up the PostgreSQL database with the provided credentials
2. Create the database schema using the SQL scripts
3. Initialize the React/TypeScript frontend project
4. Set up the Node.js/Express backend with Prisma
5. Implement authentication flow
6. Build core features (ballots, candidates, voting)
7. Test thoroughly before considering production deployment
